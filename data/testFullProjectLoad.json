{"javaInputs": [
    {
        "contents": "package model;\n\nimport java.util.Objects;\n\n// wrapper class to associate association types and arities\npublic class AssociationRelation {\n    private int arity;\n    private final AssociationType type;\n\n    // EFFECTS: creates a new association relationship with the given type and arity\n    public AssociationRelation(int arity, AssociationType type) {\n        this.arity = arity;\n        this.type = type;\n    }\n\n    // getters\n    public int getArity() {\n        return arity;\n    }\n\n    public AssociationType getType() {\n        return type;\n    }\n\n    // setters\n    public void setArity(int arity) {\n        this.arity = arity;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        AssociationRelation relation = (AssociationRelation) o;\n\n        if (arity != relation.arity) {\n            return false;\n        }\n        return type == relation.type;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(arity, type);\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/AssociationRelation.java"
    },
    {
        "contents": "package model;\n\n// possible association types\npublic enum AssociationType {\n    FIELD, AGGREGATE_FIELD, LIST_OF, AGGREGATE_LIST_OF, DEPENDENCY\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/AssociationType.java"
    },
    {
        "contents": "package model;\n\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\nimport java.util.List;\n\n// collects all class names defined in the currently parsed Java file\n// from https://stackoverflow.com/a/65733145\npublic class ClassNameCollector extends VoidVisitorAdapter<List<String>> {\n    // MODIFIES: collector\n    // EFFECTS: adds all class names found to the collector List\n    public void visit(ClassOrInterfaceDeclaration n, List<String> collector) {\n        super.visit(n, collector);\n        if (!n.isInterface()) {\n            collector.add(n.getNameAsString());\n        }\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/ClassNameCollector.java"
    },
    {
        "contents": "package model;\n\n// wrapper to create a list of possible enum\npublic enum DiagramType {\n    PACKAGE(\"package\"),\n    CLASS_IMPORT(\"imports\"),\n    CLASS_RELATIONSHIP(\"relationship\");\n\n    private final String label;\n\n    // EFFECTS: instantiates a new instance of the enum (just to associate a given string with the label)\n    DiagramType(String s) {\n        label = s;\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/DiagramType.java"
    },
    {
        "contents": "package model;\n\nimport java.util.Calendar;\nimport java.util.Date;\n\n\n/**\n * Represents an alarm system event.\n */\n// from https://github.students.cs.ubc.ca/CPSC210/AlarmSystem/blob/main/src/main/ca/ubc/cpsc210/alarm/model/Event.java\npublic class Event {\n    private static final int HASH_CONSTANT = 13;\n    private Date dateLogged;\n    private String description;\n\n    /**\n     * Creates an event with the given description\n     * and the current date/time stamp.\n     *\n     * @param description a description of the event\n     */\n    public Event(String description) {\n        dateLogged = Calendar.getInstance().getTime();\n        this.description = description;\n    }\n\n    /**\n     * Gets the date of this event (includes time).\n     *\n     * @return the date of the event\n     */\n    public Date getDate() {\n        return dateLogged;\n    }\n\n    /**\n     * Gets the description of this event.\n     *\n     * @return the description of the event\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (other == null) {\n            return false;\n        }\n\n        if (other.getClass() != this.getClass()) {\n            return false;\n        }\n\n        Event otherEvent = (Event) other;\n\n        return (this.dateLogged.equals(otherEvent.dateLogged)\n                && this.description.equals(otherEvent.description));\n    }\n\n    @Override\n    public int hashCode() {\n        return (HASH_CONSTANT * dateLogged.hashCode() + description.hashCode());\n    }\n\n    @Override\n    public String toString() {\n        return dateLogged.toString() + \"\\n\" + description;\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/Event.java"
    },
    {
        "contents": "package model;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * Represents a log of alarm system events.\n * We use the Singleton Design Pattern to ensure that there is only\n * one EventLog in the system and that the system has global access\n * to the single instance of the EventLog.\n */\n// from https://github.students.cs.ubc.ca/CPSC210/AlarmSystem/blob/main/src/main/ca/ubc/cpsc210/alarm/model/EventLog.java\npublic class EventLog implements Iterable<Event> {\n    /**\n     * the only EventLog in the system (Singleton Design Pattern)\n     */\n    private static EventLog theLog;\n    private Collection<Event> events;\n\n    /**\n     * Prevent external construction.\n     * (Singleton Design Pattern).\n     */\n    private EventLog() {\n        events = new ArrayList<Event>();\n    }\n\n    /**\n     * Gets instance of EventLog - creates it\n     * if it doesn't already exist.\n     * (Singleton Design Pattern)\n     *\n     * @return instance of EventLog\n     */\n    public static EventLog getInstance() {\n        if (theLog == null) {\n            theLog = new EventLog();\n        }\n\n        return theLog;\n    }\n\n    /**\n     * Adds an event to the event log.\n     *\n     * @param e the event to be added\n     */\n    public void logEvent(Event e) {\n        events.add(e);\n    }\n\n    /**\n     * Clears the event log and logs the event.\n     */\n    public void clear() {\n        events.clear();\n        logEvent(new Event(\"Event log cleared.\"));\n    }\n\n    @Override\n    public Iterator<Event> iterator() {\n        return events.iterator();\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/EventLog.java"
    },
    {
        "contents": "package model;\n\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n// collects all superclasses that the class in the currently parsed Java file extends\npublic class ExtendedTypesCollector extends VoidVisitorAdapter<List<String>> {\n    // MODIFIES: collector\n    // EFFECTS: adds all names of the extended superclasses to the collector List\n    public void visit(ClassOrInterfaceDeclaration n, List<String> collector) {\n        super.visit(n, collector);\n        NodeList<ClassOrInterfaceType> extendedDecls = n.getExtendedTypes();\n        List<String> extendedDeclsStrings = new ArrayList<>();\n        for (ClassOrInterfaceType decl : extendedDecls) {\n            extendedDeclsStrings.add(decl.getNameAsString());\n        }\n        collector.addAll(extendedDeclsStrings);\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/ExtendedTypesCollector.java"
    },
    {
        "contents": "package model;\n\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n// collects all interfaces that the class in the currently parsed Java file implements\npublic class ImplementedTypesCollector extends VoidVisitorAdapter<List<String>> {\n    // MODIFIES: collector\n    // EFFECTS: adds the names of all implemented interfaces to the collector List\n    public void visit(ClassOrInterfaceDeclaration n, List<String> collector) {\n        super.visit(n, collector);\n        NodeList<ClassOrInterfaceType> implementDecls = n.getImplementedTypes();\n        List<String> implementDeclStrings = new ArrayList<>();\n        for (ClassOrInterfaceType decl : implementDecls) {\n            implementDeclStrings.add(decl.getNameAsString());\n        }\n        collector.addAll(implementDeclStrings);\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/ImplementedTypesCollector.java"
    },
    {
        "contents": "package model;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.ImportDeclaration;\nimport com.github.javaparser.ast.PackageDeclaration;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport persistence.Writeable;\n\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n// parses Java files and finds class / import declarations and extends / implements relationships\npublic class ImportDiagramParser implements Writeable {\n\n    private CompilationUnit parser;\n\n    private List<JavaInput> javaInputs;\n\n    private JavaInput currentJavaInput;\n\n    // EFFECTS: initializes a Java parser with no Java files added\n    // https://github.com/javaparser/javasymbolsolver-maven-sample\n    public ImportDiagramParser() {\n        javaInputs = new ArrayList<>();\n        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();\n        combinedTypeSolver.add(new ReflectionTypeSolver());\n        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);\n        StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n    }\n\n    // EFFECTS: initializes a Java parser with a single string representing a Java file\n    public ImportDiagramParser(JavaInput javaInput) {\n        this();\n        javaInputs.add(javaInput);\n        currentJavaInput = javaInput;\n    }\n\n    // EFFECTS: initializes a Java parser with multiple strings representing Java files\n    public ImportDiagramParser(List<JavaInput> javaInputs) {\n        this();\n        this.javaInputs.addAll(javaInputs);\n        if (this.javaInputs.size() > 0) {\n            currentJavaInput = this.javaInputs.get(0);\n        }\n    }\n\n    // EFFECTS: returns the package name in the Java file currently being parsed\n    public String findPackageName() {\n        String packageName = \"\";\n        List<PackageDeclaration> packageNames = parser.findAll(PackageDeclaration.class);\n        if (packageNames.size() > 0) {\n            packageName = packageNames.get(0).getNameAsString();\n        }\n//        EventLog.getInstance().logEvent(new Event(\"Package name \" + packageName + \" found.\"));\n        return packageName;\n    }\n\n    // REQUIRES: only one class declaration in the file\n    // EFFECTS: returns the class / interface name in the file currently being parsed (assumes there is only one; if\n    // there are more than one return the first class declaration encountered)\n    public TypeNameDeclaration findTypeName() {\n        List<String> classNames = new ArrayList<>();\n        ClassNameCollector classNameVisitor = new ClassNameCollector();\n        classNameVisitor.visit(parser, classNames);\n\n        List<String> interfaceNames = new ArrayList<>();\n        InterfaceNameCollector interfaceNameCollector = new InterfaceNameCollector();\n        interfaceNameCollector.visit(parser, interfaceNames);\n\n        String typeName = null;\n        if (classNames.size() > 0) {\n            typeName = classNames.get(0);\n        } else if (interfaceNames.size() > 0) {\n            typeName = interfaceNames.get(0);\n        }\n//        EventLog.getInstance().logEvent(new Event(\"Type name \" + typeName + \" found.\"));\n        return new TypeNameDeclaration(typeName, interfaceNames.contains(typeName));\n    }\n\n    // EFFECTS: returns the full type name (\"[package name].[class/interface name]\")\n    public String findFinalTypeName() {\n        String packageName = findPackageName();\n        String className = findTypeName().getName();\n        if (className == null) {\n            return \"\";\n        }\n        String finalName = (packageName.trim().length() != 0 ? packageName + \".\" : \"\") + className;\n//        EventLog.getInstance().logEvent(new Event(\"Final type name \" + finalName + \" found.\"));\n        return finalName;\n    }\n\n    // REQUIRES: only one class declaration in the file\n    // EFFECTS: returns all interfaces the current class implements\n    public List<String> findImplementedInterfaces() {\n        return findSuperTypes(new ImplementedTypesCollector());\n    }\n\n    // REQUIRES: only one class declaration in the file\n    // EFFECTS: returns all superclasses the current class extends\n    public List<String> findExtendedClasses() {\n        return findSuperTypes(new ExtendedTypesCollector());\n    }\n\n    // EFFECTS: visits all nodes and returns all interfaces or superclasses that this class is a subclass of\n    private List<String> findSuperTypes(VoidVisitorAdapter<List<String>> collector) {\n        List<String> typeNames = new ArrayList<>();\n        collector.visit(parser, typeNames);\n        return typeNames;\n    }\n\n    // TODO - resolve wildcard imports\n    // REQUIRES: no wildcard imports in currently parsed Java file\n    // EFFECTS: returns all explicit imports in the Java code that aren't from Java STDLIB\n    public List<ImportDeclaration> findAllExplicitImports() {\n        List<String> externalDefaultImports = Arrays.asList(\"java\", \"com\", \"ca\", \"org\");\n        List<ImportDeclaration> imports = parser.findAll(ImportDeclaration.class);\n        List<ImportDeclaration> sanitizedImports = new ArrayList<>();\n        for (ImportDeclaration importDecl : imports) {\n            if (!importDecl.getNameAsString().contains(\".\") || !externalDefaultImports.contains(\n                    importDecl.getNameAsString().substring(0, importDecl.getNameAsString().indexOf(\".\")))) {\n                sanitizedImports.add(importDecl);\n            }\n        }\n//        EventLog.getInstance().logEvent(new Event(\"Explicit imports \" + sanitizedImports + \" found.\"));\n        return sanitizedImports;\n    }\n\n    // REQUIRES: none of the current javaInputs have wildcard imports\n    // MODIFIES: this\n    // EFFECTS: finds all implicit imports in fromFile from the files currently added to the diagram\n    // heuristic: if there are occurrences of a class name in fromFile and fromFile doesn't import any other classes\n    // that could provide this name, it should come from fromFile\n    public List<String> findAllImplicitImports(JavaInput fromFile) {\n        this.currentJavaInput = fromFile;\n        Set<String> typeNames = findAllTypeNamesInInputs();\n\n        setParser(StaticJavaParser.parse(fromFile.getJavaContents()));\n        List<ImportDeclaration> explicitImports = findAllExplicitImports();\n        String currentTypeName = findTypeName().getName();\n        String currentPackageName = findPackageName();\n\n        Set<String> explicitImportStrings = new HashSet<>();\n        for (ImportDeclaration explicitImport : explicitImports) {\n            explicitImportStrings.add(explicitImport.getName().getIdentifier());\n        }\n\n        Set<String> implicitImports = new HashSet<>();\n        for (String typeName : typeNames) {\n            Pattern regex = Pattern.compile(\"([^a-zA-Z\\\\d]\" + typeName + \"[^a-zA-Z\\\\d])\");\n            Matcher matcher = regex.matcher(fromFile.getJavaContents());\n            if (!explicitImportStrings.contains(typeName) && !typeName.equals(currentTypeName) && matcher.find()) {\n                implicitImports.add(\n                        (currentPackageName.trim().length() != 0 ? currentPackageName + \".\" : \"\") + typeName);\n            }\n        }\n//        EventLog.getInstance().logEvent(new Event(\"Explicit imports \" + implicitImports + \" found.\"));\n        return new ArrayList<>(implicitImports);\n    }\n\n    // MODIFIES: this\n    // EFFECTS: creates a mapping of imported TypeName to their associations in the current class\n    public Map<String, List<AssociationRelation>> findAllAssociations() {\n        Set<String> typeNames = findAllFullTypeNamesInInputs();\n        List<FieldDeclaration> fields = findAllFields();\n        Map<String, List<AssociationRelation>> map = new HashMap<>();\n        mapToAssociations(typeNames, fields, map);\n//        EventLog.getInstance().logEvent(new Event(\"All JavaInputs have been mapped to their associations.\"));\n        return map;\n    }\n\n    // MODIFIES: typeNames, fields, map\n    // EFFECTS: associates each class mentioned in a field in the current class to an arity and association type\n    // dependency heuristic:  if it's mentioned in the file and is not a field, it's a dependency\n    private void mapToAssociations(Set<String> typeNames, List<FieldDeclaration> fields,\n                                   Map<String, List<AssociationRelation>> map) {\n        String currentTypeName = findTypeName().getName();\n        for (String typeName : typeNames) {\n            if (typeName.equals(currentTypeName)) { // TODO - don't ignore if static self-referential\n                continue;\n            }\n            for (FieldDeclaration field : fields) {\n                createAssociationRelationshipsForFields(fields, map, typeName, field);\n            }\n            if (currentJavaInput.getJavaContents().contains(typeName) && !map.containsKey(typeName)) {\n                AssociationRelation ar = new AssociationRelation(-1,\n                        AssociationType.DEPENDENCY);\n                List<AssociationRelation> dependencyARList = new ArrayList<>();\n                dependencyARList.add(ar);\n                map.put(typeName, dependencyARList);\n            }\n        }\n    }\n\n    // MODIFIES: map\n    // EFFECTS: creates association relation objects for every field relationship, returns true if fields were added\n    private void createAssociationRelationshipsForFields(List<FieldDeclaration> fields,\n                                                         Map<String, List<AssociationRelation>> map,\n                                                         String typeName, FieldDeclaration field) {\n        boolean isAggregation = field.getComment().toString().contains(\n                \"UMLIE_AGGREGATION\");\n        boolean isListOf =\n                field.getCommonType().asString().equals(\"List<\" + typeName + \">\") || field.getCommonType()\n                        .asString().startsWith(\"ArrayList<\" + typeName + \">\");\n        int fieldCount = (int) fields.stream().filter(fieldDeclaration -> isListOf ? (\n                fieldDeclaration.getCommonType().asString().equals(\"List<\" + typeName + \">\")\n                        || field.getCommonType().asString().startsWith(\"ArrayList<\" + typeName + \">\"))\n                : fieldDeclaration.getCommonType().asString().equals(typeName)).count();\n        AssociationRelation ar = new AssociationRelation(fieldCount,\n                isListOf ? (isAggregation ? AssociationType.AGGREGATE_LIST_OF : AssociationType.LIST_OF) :\n                        (isAggregation ? AssociationType.AGGREGATE_FIELD : AssociationType.FIELD));\n        if (map.containsKey(typeName)) {\n            if (isListOf || !map.get(typeName).contains(ar)) {\n                map.get(typeName).add(ar);\n            }\n        } else {\n            List<AssociationRelation> newARList = new ArrayList<>();\n            newARList.add(ar);\n            map.put(typeName, newARList);\n        }\n    }\n\n    // REQUIRES: this.currentJavaInput is set\n    // MODIFIES: this\n    // EFFECTS: finds all the types declared in all javaInputs\n    private Set<String> findAllTypeNamesInInputs() {\n        Set<String> typeNames = new HashSet<>();\n        for (JavaInput javaInput : javaInputs) {\n            setParser(StaticJavaParser.parse(javaInput.getJavaContents()));\n            String typeName = findTypeName().getName();\n            if (typeName != null) {\n                typeNames.add(typeName);\n            }\n        }\n        setParser(StaticJavaParser.parse(currentJavaInput.getJavaContents()));\n        return typeNames;\n    }\n\n    // REQUIRES: this.currentJavaInput is set\n    // MODIFIES: this\n    // EFFECTS: finds all the types declared in all javaInputs, with their fully quantified package names\n    private Set<String> findAllFullTypeNamesInInputs() {\n        Set<String> typeNames = new HashSet<>();\n        for (JavaInput javaInput : javaInputs) {\n            setParser(StaticJavaParser.parse(javaInput.getJavaContents()));\n            String typeName = findFinalTypeName();\n            typeNames.add(typeName);\n        }\n        setParser(StaticJavaParser.parse(currentJavaInput.getJavaContents()));\n        return typeNames;\n    }\n\n    // EFFECTS: finds all fields / associations declared in a class\n    private List<FieldDeclaration> findAllFields() {\n        List<FieldDeclaration> fields = new ArrayList<>();\n        for (TypeDeclaration typeDec : parser.getTypes()) {\n            List<BodyDeclaration> members = typeDec.getMembers();\n            for (BodyDeclaration member : members) {\n                if (member instanceof FieldDeclaration) {\n                    FieldDeclaration field = (FieldDeclaration) member;\n                    fields.add(field);\n                }\n            }\n        }\n        return fields;\n    }\n\n    // MODIFIES: this\n    // EFFECTS: adds a Java file to the project being parsed and logs to the event log\n    public void addJavaInput(JavaInput javaInput) {\n        javaInputs.add(javaInput);\n        EventLog.getInstance().logEvent(new Event(\"JavaInput with name \" + javaInput.getShortName() + \" added.\"));\n    }\n\n    // MODIFIES: this\n    // EFFECTS: removes the given Java input from the list of inputs if it exists in the list already\n    public void removeJavaInput(JavaInput javaInput) {\n        javaInputs.remove(javaInput);\n        EventLog.getInstance().logEvent(new Event(\"JavaInput with name \" + javaInput.getShortName() + \" removed.\"));\n    }\n\n    // MODIFIES: this\n    // EFFECTS: clears all Java inputs\n    public void clearJavaInputs() {\n        javaInputs = new ArrayList<>();\n        EventLog.getInstance().logEvent(new Event(\"JavaInputs cleared.\"));\n    }\n\n    @Override\n    public JSONObject toJson() {\n        JSONObject json = new JSONObject();\n        json.put(\"javaInputs\", javaInputsToJson());\n        return json;\n    }\n\n    // EFFECTS: returns a JSONArray containing all Java Inputs\n    private JSONArray javaInputsToJson() {\n        JSONArray jsonArray = new JSONArray();\n\n        for (JavaInput javaInput : javaInputs) {\n            jsonArray.put(javaInput.toJson());\n        }\n\n        return jsonArray;\n    }\n\n    // getters\n\n    public List<JavaInput> getJavaInputs() {\n        return javaInputs;\n    }\n\n    public JavaInput getCurrentJavaInput() {\n        return currentJavaInput;\n    }\n\n    // setters\n\n    public void setParser(CompilationUnit parser) {\n        this.parser = parser;\n    }\n\n    public void setCurrentJavaInput(JavaInput javaInput) {\n        this.currentJavaInput = javaInput;\n    }\n\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/ImportDiagramParser.java"
    },
    {
        "contents": "package model;\n\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\nimport java.util.List;\n\n// collects all interfaces defined in the currently parsed Java file\npublic class InterfaceNameCollector extends VoidVisitorAdapter<List<String>> {\n    // MODIFIES: collector\n    // EFFECTS: adds the names of all interfaces found to the collector List\n    public void visit(ClassOrInterfaceDeclaration n, List<String> collector) {\n        super.visit(n, collector);\n        if (n.isInterface()) {\n            collector.add(n.getNameAsString());\n        }\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/InterfaceNameCollector.java"
    },
    {
        "contents": "package model;\n\nimport org.json.JSONObject;\nimport persistence.Writeable;\n\n// wrapper class to associate a shortname with the contents of a Java file\npublic class JavaInput implements Writeable {\n    private final String shortName;\n    private final String javaContents;\n\n    // REQUIRES: javaContents is valid Java code\n    // EFFECTS: instantiates an input object with the given nickname and contents\n    public JavaInput(String shortName, String javaContents) {\n        this.shortName = shortName;\n        this.javaContents = javaContents;\n    }\n\n    @Override\n    public JSONObject toJson() {\n        JSONObject json = new JSONObject();\n        json.put(\"shortName\", shortName);\n        json.put(\"contents\", javaContents);\n        return json;\n    }\n\n    // getters\n\n    public String getShortName() {\n        return shortName;\n    }\n\n    public String getJavaContents() {\n        return javaContents;\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/JavaInput.java"
    },
    {
        "contents": "package model;\n\nimport java.util.Objects;\n\n// wrapper, keeps track of a type definition and whether it was declared as an interface or class\npublic class TypeNameDeclaration {\n    private final String name;\n    private final boolean isInterface;\n\n    // EFFECTS: constructs a type name declaration with the given name, defaulting isInterface to false\n    public TypeNameDeclaration(String name) {\n        this.name = name;\n        this.isInterface = false;\n    }\n\n    // EFFECTS: constructs a type name declaration with the given name and interface type\n    public TypeNameDeclaration(String name, boolean isInterface) {\n        this.name = name;\n        this.isInterface = isInterface;\n    }\n\n    // getters\n\n    public String getName() {\n        return name;\n    }\n\n    public boolean isInterface() {\n        return isInterface;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        TypeNameDeclaration that = (TypeNameDeclaration) o;\n\n        if (isInterface != that.isInterface) {\n            return false;\n        }\n        return name.equals(that.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, isInterface);\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/TypeNameDeclaration.java"
    },
    {
        "contents": "package model;\n\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.ast.ImportDeclaration;\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n// generates UML for package relationship and class import diagrams\npublic class UMLangGenerator {\n\n    private ImportDiagramParser parser;\n\n    // EFFECTS: initializes a new diagram generator with an ImportDiagramParser\n    public UMLangGenerator(ImportDiagramParser parser) {\n        this.parser = parser;\n    }\n\n    // MODIFIES: this\n    // EFFECTS: generates the package import diagram for all Java inputs currently loaded in the parser\n    // (package import diagram maps only the relationships between, and not inside, packages)\n    public String generateUMLangPackageRelationshipDiagram() {\n        String uml = \"\";\n        Set<String> packages = new HashSet<>();\n        Set<String> imports = new HashSet<>();\n\n        generateInterPackageImportUML(packages, imports);\n\n        for (String packageName : packages) {\n            uml = uml.concat(packageName + \"\\n\");\n        }\n\n        for (String importDecl : imports) {\n            uml = uml.concat(importDecl + \"\\n\");\n        }\n\n        EventLog.getInstance().logEvent(new Event(\"Package relationship diagram generated.\"));\n        return wrapUml(uml);\n    }\n\n    // MODIFIES: this\n    // EFFECTS: generates the class (intra-package) import diagram for all Java inputs currently loaded in the parser\n    public String generateClassImportDiagram() {\n        String uml = \"\";\n\n        for (JavaInput javaInput : parser.getJavaInputs()) {\n            String javaContents = javaInput.getJavaContents();\n            parser.setParser(StaticJavaParser.parse(javaContents));\n\n            TypeNameDeclaration typeName = parser.findTypeName();\n            List<ImportDeclaration> explicitImports = parser.findAllExplicitImports();\n            List<String> implicitImports = parser.findAllImplicitImports(javaInput);\n            String finalPackageName = parser.findFinalTypeName();\n\n            uml = uml.concat((typeName.isInterface() ? \"interface \" : \"class \") + finalPackageName + \"\\n\");\n            for (ImportDeclaration importDecl : explicitImports) {\n                uml = uml.concat(finalPackageName + \" -> \" + importDecl.getNameAsString() + \"\\n\");\n            }\n            for (String importDecl : implicitImports) {\n                uml = uml.concat(finalPackageName + \" -> \" + importDecl + \"\\n\");\n            }\n        }\n\n        EventLog.getInstance().logEvent(new Event(\"Class import diagram generated.\"));\n\n        return wrapUml(uml);\n    }\n\n    // MODIFIES: this\n    // EFFECTS: generates the class (intra-package) import diagram for all Java inputs currently loaded\n    public String generateClassRelationshipDiagram() {\n        String uml = \"\";\n\n        for (JavaInput javaInput : parser.getJavaInputs()) {\n            parser.setCurrentJavaInput(javaInput);\n            String javaContents = javaInput.getJavaContents();\n            parser.setParser(StaticJavaParser.parse(javaContents));\n\n            TypeNameDeclaration typeName = parser.findTypeName();\n            List<ImportDeclaration> explicitImports = parser.findAllExplicitImports();\n            List<String> implicitImports = parser.findAllImplicitImports(javaInput);\n            String finalPackageName = getParser().findFinalTypeName();\n\n            uml = uml.concat((typeName.isInterface() ? \"interface \" : \"class \") + finalPackageName + \"\\n\");\n            uml = uml.concat(generateSuperTypesUML(finalPackageName, explicitImports, implicitImports,\n                    parser.findImplementedInterfaces(), true));\n            uml = uml.concat(generateSuperTypesUML(finalPackageName, explicitImports, implicitImports,\n                    parser.findExtendedClasses(), false));\n\n            uml = uml.concat(generateAssociationRelationsUML());\n            // uml = uml.concat(generateDependencyRelationsUML(uml)); // TODO - uncomment me\n        }\n\n        EventLog.getInstance().logEvent(new Event(\"Class relationship diagram generated.\"));\n\n        return wrapUml(uml);\n    }\n\n    // MODIFIES: this\n    // EFFECTS: generates the correct diagram for the provided diagram type\n    public String generateDiagramForType(DiagramType type) {\n        switch (type) {\n            case CLASS_IMPORT:\n                return generateClassImportDiagram();\n            case CLASS_RELATIONSHIP:\n                return generateClassRelationshipDiagram();\n            default:\n                return generateUMLangPackageRelationshipDiagram();\n        }\n    }\n\n    // MODIFIES: this\n    // EFFECTS: generates the UML association arrows for a map of association relationships\n    private String generateAssociationRelationsUML() {\n        String uml = \"\";\n        Map<String, List<AssociationRelation>> associationRelations = parser.findAllAssociations();\n        for (String key : associationRelations.keySet()) {\n            List<AssociationRelation> relationships = associationRelations.get(key);\n            for (AssociationRelation relationship : relationships) {\n                if (relationship.getType() == AssociationType.DEPENDENCY) {\n                    continue;\n                }\n                uml = uml.concat(parser.findFinalTypeName() + \" \" + (relationship.getType() == AssociationType.FIELD\n                        || relationship.getType() == AssociationType.LIST_OF ? \"-->\" : \"o-->\") + \" \\\"\" + (\n                        relationship.getType() != AssociationType.AGGREGATE_LIST_OF\n                                && relationship.getType() != AssociationType.LIST_OF ? relationship.getArity() : \"0..*\")\n                        + \"\\\" \" + key + \"\\n\");\n            }\n        }\n        return uml;\n    }\n\n    // MODIFIES: this\n    // EFFECTS: generates the UML dependency arrows for a map of association relationships\n    private String generateDependencyRelationsUML(String currentUml) {\n        String uml = \"\";\n        Map<String, List<AssociationRelation>> associationRelations = parser.findAllAssociations();\n        for (String key : associationRelations.keySet()) {\n            List<AssociationRelation> relationships = associationRelations.get(key);\n            for (AssociationRelation relationship : relationships) {\n                Pattern regex = Pattern.compile(\n                        \"(\" + parser.findFinalTypeName().replace(\".\", \"\\\\.\") + \" [-\\\\.|]+> \" + key.replace(\".\", \"\\\\.\")\n                                + \"[^a-zA-Z\\\\d])\");\n                Matcher matcher = regex.matcher(currentUml);\n                if (relationship.getType() == AssociationType.DEPENDENCY && !matcher.find()) {\n                    uml = uml.concat(parser.findFinalTypeName() + \" -.-> \" + key + \"\\n\");\n                }\n            }\n        }\n        return uml;\n    }\n\n\n    // MODIFIES: this, packages, imports\n    // EFFECTS: appends the UML for the set of packages to the given packages Object, and appends the UML for the\n    // package dependencies to the given imports Object\n    private void generateInterPackageImportUML(Set<String> packages, Set<String> imports) {\n        for (JavaInput javaInput : parser.getJavaInputs()) {\n            String javaContents = javaInput.getJavaContents();\n            parser.setParser(StaticJavaParser.parse(javaContents));\n\n            String packageName = parser.findPackageName();\n            List<ImportDeclaration> importDecls = parser.findAllExplicitImports();\n\n            if (packageName.trim().length() != 0) {\n                packages.add(\"folder \" + packageName);\n                for (ImportDeclaration importDecl : importDecls) {\n                    String importDeclString = importDecl.getNameAsString();\n                    if (!importDeclString.contains(packageName)) {\n                        imports.add(packageName + \" -> \" + importDeclString.substring(0,\n                                importDeclString.lastIndexOf('.')));\n                    }\n                }\n            }\n\n        }\n    }\n\n    // REQUIRES: all elements in superTypes are in at least one of explicitImports and implicitImports\n    // EFFECTS: generates the UML representing class inheritance hierarchies for a class given its explicit /\n    // implicit imports, supertypes, and its extension type (implementation or extension)\n    private String generateSuperTypesUML(String finalPackageName, List<ImportDeclaration> explicitImports,\n                                         List<String> implicitImports, List<String> superTypes, boolean isImplemented) {\n        String uml = \"\";\n        for (String implementedType : superTypes) {\n            for (ImportDeclaration importDecl : explicitImports) {\n                if (importDecl.getNameAsString().substring(importDecl.getNameAsString().lastIndexOf('.') + 1)\n                        .equals(implementedType)) {\n                    uml = uml.concat(finalPackageName + \" \" + (isImplemented ? \"..|>\" : \"--|>\") + \" \"\n                            + importDecl.getNameAsString() + \"\\n\");\n                }\n            }\n            for (String importDecl : implicitImports) {\n                if (importDecl.substring(importDecl.lastIndexOf('.') + 1).equals(implementedType)) {\n                    uml = uml.concat(\n                            finalPackageName + \" \" + (isImplemented ? \"..|>\" : \"--|>\") + \" \" + importDecl + \"\\n\");\n                }\n            }\n        }\n        return uml;\n    }\n\n    // EFFECTS: wraps the provided string in \"@startuml\" and \"@enduml\" tags\n    private String wrapUml(String uml) {\n        return \"@startuml\\n\" + uml + \"@enduml\";\n    }\n\n    // getters\n\n    public ImportDiagramParser getParser() {\n        return parser;\n    }\n\n    // setters\n\n    public void setParser(ImportDiagramParser parser) {\n        this.parser = parser;\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/model/UMLangGenerator.java"
    },
    {
        "contents": "package persistence;\n\nimport model.ImportDiagramParser;\nimport model.JavaInput;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.stream.Stream;\n\n// adapted from https://github.students.cs.ubc.ca/CPSC210/JsonSerializationDemo/blob/master/src/main/persistence/JsonReader.java\n// reads JSON from a file and loads it into the parser\npublic class JsonReader {\n    private final String source;\n\n    // EFFECTS: constructs reader to read from source file\n    public JsonReader(String source) {\n        this.source = source;\n    }\n\n    // EFFECTS: reads parser from file and returns it;\n    // throws IOException if an error occurs reading data from file\n    public ImportDiagramParser read() throws IOException {\n        String jsonData = readFile(source);\n        JSONObject jsonObject = new JSONObject(jsonData);\n        return parseParser(jsonObject);\n    }\n\n    // EFFECTS: reads source file as string and returns it\n    private String readFile(String source) throws IOException {\n        StringBuilder contentBuilder = new StringBuilder();\n\n        try (Stream<String> stream = Files.lines(Paths.get(source), StandardCharsets.UTF_8)) {\n            stream.forEach(contentBuilder::append);\n        }\n\n        return contentBuilder.toString();\n    }\n\n    // EFFECTS: parses diagram parser from JSON object and returns it\n    private ImportDiagramParser parseParser(JSONObject jsonObject) {\n        ImportDiagramParser parser = new ImportDiagramParser();\n        addJavaInputs(parser, jsonObject);\n        return parser;\n    }\n\n    // MODIFIES: parser\n    // EFFECTS: parses JavaInputs from JSON array and adds them to parser\n    private void addJavaInputs(ImportDiagramParser parser, JSONObject jsonObject) {\n        JSONArray jsonArray = jsonObject.getJSONArray(\"javaInputs\");\n        for (Object json : jsonArray) {\n            JSONObject nextThingy = (JSONObject) json;\n            addJavaInput(parser, nextThingy);\n        }\n    }\n\n    // MODIFIES: parser\n    // EFFECTS: parses JavaInput from JSON object and adds it to workroom\n    private void addJavaInput(ImportDiagramParser parser, JSONObject jsonObject) {\n        JavaInput javaInput = new JavaInput(jsonObject.getString(\"shortName\"), jsonObject.getString(\"contents\"));\n        parser.addJavaInput(javaInput);\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/persistence/JsonReader.java"
    },
    {
        "contents": "package persistence;\n\nimport model.ImportDiagramParser;\nimport org.json.JSONObject;\n\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\n\n// adapted from https://github.students.cs.ubc.ca/CPSC210/JsonSerializationDemo/blob/master/src/main/persistence/JsonWriter.java\n// writes JSON to a file\npublic class JsonWriter {\n    private static final int TAB_SIZE = 4;\n    private PrintWriter writer;\n    private final String destination;\n\n    // EFFECTS: constructs writer to write to destination file\n    public JsonWriter(String destination) {\n        this.destination = destination;\n    }\n\n    // MODIFIES: this\n    // EFFECTS: opens writer; throws FileNotFoundException if destination file cannot\n    // be opened for writing\n    private void open() throws FileNotFoundException {\n        writer = new PrintWriter(destination);\n    }\n\n    // MODIFIES: this\n    // EFFECTS: writes JSON representation of parser to file\n    public void write(ImportDiagramParser parser) throws FileNotFoundException {\n        open();\n        JSONObject json = parser.toJson();\n        saveToFile(json.toString(TAB_SIZE));\n        close();\n    }\n\n    // MODIFIES: this\n    // EFFECTS: closes writer\n    private void close() {\n        writer.close();\n    }\n\n    // MODIFIES: this\n    // EFFECTS: writes string to file\n    private void saveToFile(String json) {\n        writer.print(json);\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/persistence/JsonWriter.java"
    },
    {
        "contents": "package persistence;\n\nimport model.UMLangGenerator;\nimport model.DiagramType;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n// writes UML files (outputs of UMLangGenerator) to disk\npublic class UMLangWriter {\n    private final String destination;\n    private final UMLangGenerator generator;\n\n    // EFFECTS: constructs a UML writer with a filepath destination and the current UML diagram generator\n    public UMLangWriter(String destination, UMLangGenerator generator) {\n        this.destination = destination;\n        this.generator = generator;\n    }\n\n    // EFFECTS: writes the current diagram as UML to a file on disk\n    public void writeUML(DiagramType diagramType) throws IOException {\n        FileWriter fileWriter = new FileWriter(destination);\n        fileWriter.write(generator.generateDiagramForType(diagramType));\n        fileWriter.close();\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/persistence/UMLangWriter.java"
    },
    {
        "contents": "package persistence;\n\nimport org.json.JSONObject;\n\n// taken from https://github.students.cs.ubc.ca/CPSC210/JsonSerializationDemo/blob/master/src/main/persistence/Writable.java\n// implemented by objects that can be written to JSON / files\npublic interface Writeable {\n\n    // EFFECTS: returns this as JSON object\n    JSONObject toJson();\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/persistence/Writeable.java"
    },
    {
        "contents": "package ui;\n\n// runs app and instantiates UMLieApp instance\npublic class Main {\n    // EFFECTS: instantiates a new instance of the UMLie app\n    public static void main(String[] args) {\n        // new UMLieConsoleApp();\n        new UMLieGUI();\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/ui/Main.java"
    },
    {
        "contents": "package ui;\n\nimport model.DiagramType;\nimport model.ImportDiagramParser;\nimport model.JavaInput;\nimport model.UMLangGenerator;\nimport persistence.JsonReader;\nimport persistence.JsonWriter;\nimport persistence.UMLangWriter;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Stream;\n\n// collects user input and dispatches method calls to the parser and diagram generator\n// input loop adapted from TellerApp example - https://github.students.cs.ubc.ca/CPSC210/TellerApp\npublic class UMLieConsoleApp {\n\n    private static final Pattern PACKAGE_NAME_REGEX = Pattern.compile(\"src\\\\/(main\\\\/(java\\\\/)?)?(.*)\\\\/(.*).java\");\n\n    private ImportDiagramParser parser;\n    private final UMLangGenerator generator;\n    // private Map<String, String> fileContents;\n    private final Scanner input;\n    private final Set<String> takenShortNames;\n\n    // EFFECTS: instantiates a new instance of the app and runs the input loop\n    public UMLieConsoleApp() {\n        parser = new ImportDiagramParser();\n        generator = new UMLangGenerator(parser);\n        // fileContents = new HashMap<>();\n        input = new Scanner(System.in);\n        input.useDelimiter(\"\\n\");\n        takenShortNames = new HashSet<>();\n        runInputLoop();\n    }\n\n    // MODIFIES: this\n    // EFFECTS: welcomes the user and infinitely loops while asking for a command to perform\n    private void runInputLoop() {\n        boolean keepGoing = true;\n        String command;\n\n        System.out.println(\"Welcome to UMLie - a UML diagram generator for Java projects.\");\n\n        while (keepGoing) {\n            printOptions();\n            command = input.next();\n            command = command.toLowerCase();\n\n            if (command.equals(\"q\")) {\n                keepGoing = false;\n                System.out.println(\"Save before quitting? (y/n)\");\n                command = input.next().toLowerCase();\n                if (command.equals(\"y\")) {\n                    saveJson();\n                }\n            } else {\n                processCommand(command);\n            }\n        }\n\n        System.out.println(\"\\nThanks for using UMLie!\");\n    }\n\n    // MODIFIES: this\n    // EFFECTS: executes the appropriate function based on the command\n    private void processCommand(String command) {\n        System.out.println();\n        switch (command) {\n            case \"new\":\n                resetState();\n                break;\n            case \"addfile\":\n            case \"add\": {\n                addFile();\n                break;\n            }\n            case \"removefile\":\n            case \"remove\": {\n                removeFile();\n                break;\n            }\n            case \"list\": {\n                printFileSummaries();\n                break;\n            }\n            default:\n                processOtherCommandsI(command);\n        }\n        System.out.println();\n    }\n\n    // MODIFIES: this\n    // EFFECTS: executes the appropriate function based on the command, split into two functions for line-length\n    // requirements\n    private void processOtherCommandsI(String command) {\n        switch (command) {\n            case \"savejson\":\n            case \"save\": {\n                saveJson();\n                break;\n            }\n            case \"loadjson\":\n            case \"load\": {\n                readJson();\n                break;\n            }\n            case \"package\": {\n                System.out.println(generator.generateUMLangPackageRelationshipDiagram());\n                break;\n            }\n            case \"imports\": {\n                System.out.println(generator.generateClassImportDiagram());\n                break;\n            }\n            default:\n                processOtherCommandsII(command);\n        }\n\n    }\n\n    // EFFECTS: executes the appropriate function based on the command, split into two functions for line-length\n    // requirements\n    private void processOtherCommandsII(String command) {\n        switch (command) {\n            case \"relationship\": {\n                System.out.println(generator.generateClassRelationshipDiagram());\n                break;\n            }\n            case \"export\": {\n                try {\n                    exportDiagram();\n                } catch (IOException e) {\n                    System.out.println(\"Error saving the file, please try again with a different filepath.\");\n                }\n                break;\n            }\n            default:\n                System.out.println(\"Invalid command.\");\n        }\n    }\n\n    // MODIFIES: this\n    // EFFECTS: reads JSON and replaces the current diagram parser with the loaded parser\n    private void readJson() {\n        System.out.println(\"Enter a filepath:\");\n        String filePath = input.next();\n        JsonReader jsonReader = new JsonReader(filePath);\n        try {\n            parser = jsonReader.read();\n        } catch (IOException e) {\n            System.out.println(\"Error reading the file.\");\n        }\n        generator.setParser(parser);\n    }\n\n    // EFFECTS: exports the current diagram to a filepath on disk\n    private void exportDiagram() throws IOException {\n        System.out.println(\"Enter a filepath:\");\n        String filePath = input.next();\n        System.out.println(\"Enter a diagram type (package, imports, relationship):\");\n        String diagramType = input.next();\n        UMLangWriter writer = new UMLangWriter(filePath, generator);\n        try {\n            writer.writeUML(DiagramType.valueOf(diagramType));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"That diagram type doesn't exist.\");\n        }\n    }\n\n    // EFFECTS: prints a list of the type names defined in each input\n    private void printFileSummaries() {\n        List<JavaInput> javaInputs = this.parser.getJavaInputs();\n        if (javaInputs.size() == 0) {\n            System.out.println(\"No files added.\");\n            return;\n        }\n        int i = 0;\n        for (JavaInput javaInput : javaInputs) {\n            System.out.println(\"(\" + (i + 1) + \") - \" + javaInput.getShortName());\n            i += 1;\n        }\n    }\n\n    // MODIFIES: this\n    // EFFECTS: prints filepath of each file added and asks the user which they would like to remove from the parser\n    private void removeFile() {\n        List<JavaInput> javaInputs = this.parser.getJavaInputs();\n        if (this.parser.getJavaInputs().size() == 0) {\n            System.out.println(\"No files have been added.\");\n            return;\n        }\n        System.out.println(\"Choose a file to remove:\");\n        printFileSummaries();\n        int choice = input.nextInt();\n        if (!(0 < choice && choice <= javaInputs.size())) {\n            System.out.println(\"Choice out of range. Try again.\");\n            return;\n        }\n        choice -= 1;\n        JavaInput chosenInput = javaInputs.get(choice);\n        parser.removeJavaInput(chosenInput);\n        takenShortNames.remove(chosenInput.getShortName());\n    }\n\n    // MODIFIES: this\n    // EFFECTS: asks the user for a filepath to add to the diagram, checks if the input ends in .java\n    private void addFile() {\n        System.out.println(\"Enter a filepath:\");\n        String filePath = input.next();\n        if (filePath.length() == 0 || this.takenShortNames.contains(filePath)) {\n            System.out.println(filePath + \" has been added already. Please choose another name.\");\n            return;\n        }\n        if (!filePath.endsWith(\".java\")) {\n            System.out.println(\"This doesn't look like a Java file. Please rename your file to end in .java or try \"\n                    + \"another Java file.\");\n            return;\n        }\n        addFileToParser(filePath);\n    }\n\n    // REQUIRES: filePath is a well-formed filepath\n    // MODIFIES: this\n    // EFFECTS: patches on a package declaration if one doesn't exist and adds the file to the parser\n    private void addFileToParser(String filePath) {\n        // adapted from https://howtodoinjava.com/java/io/java-read-file-to-string-examples/#2-using-fileslines-java-8\n        StringBuilder contentBuilder = new StringBuilder();\n        String fileContents;\n        try (Stream<String> stream = Files.lines(Paths.get(filePath), StandardCharsets.UTF_8)) {\n            stream.forEach(s -> contentBuilder.append(s).append(\"\\n\"));\n            fileContents = contentBuilder.toString().trim();\n            if (fileContents.length() != 0) {\n                // if no package declaration, try to create one from the pathname\n                if (!fileContents.trim().startsWith(\"package\")) {\n                    Matcher matcher = PACKAGE_NAME_REGEX.matcher(filePath);\n                    if (matcher.find() && matcher.group(2).length() == 0) {\n                        String packageName = matcher.group(2).replace(\"\\\\/\", \".\");\n                        fileContents = \"package \" + packageName + \";\\n\" + fileContents;\n                    }\n                }\n                this.parser.addJavaInput(new JavaInput(filePath, fileContents));\n                this.takenShortNames.add(filePath);\n            } else {\n                System.out.println(\"File was empty or could not be read. Try another file.\");\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n    }\n\n    // MODIFIES: this\n    // EFFECTS: resets the state of the app and instantiates new objects\n    private void resetState() {\n        System.out.println(\"Clearing previous files...\");\n        parser = new ImportDiagramParser();\n        generator.setParser(parser);\n    }\n\n    // EFFECTS: prints a command menu\n    private void printOptions() {\n        System.out.println(\"Commands:\");\n        System.out.println(\"- new to reset and create a new diagram\");\n        System.out.println(\"- addfile to add a file to your current diagram\");\n        System.out.println(\"- package to generate a package relationship diagram\");\n        System.out.println(\"- imports to generate an inter-class import relationship diagram\");\n        System.out.println(\"- relationship to generate an inter-class type extension diagram\");\n        System.out.println(\"- export to save a diagram as a UML file\");\n        System.out.println(\"- removefile to remove a file from your current diagram\");\n        System.out.println(\"- savejson to save your current diagram inputs to JSON\");\n        System.out.println(\"- loadjson to load a JSON state file into a diagram\");\n        System.out.println(\"- list to list current files\");\n        System.out.println(\"- q to quit\");\n    }\n\n    // EFFECTS: saves the current diagram parser to JSON\n    private void saveJson() {\n        System.out.println(\"Enter a filepath:\");\n        String filePath = input.next();\n        JsonWriter writer = new JsonWriter(filePath);\n        try {\n            writer.write(parser);\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Error saving to \" + filePath);\n            return;\n        }\n        System.out.println(\"Saved to \" + filePath + \"!\");\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/ui/UMLieConsoleApp.java"
    },
    {
        "contents": "package ui;\n\nimport model.*;\nimport persistence.JsonReader;\nimport persistence.JsonWriter;\nimport ui.components.*;\n\nimport javax.swing.*;\nimport javax.swing.border.EmptyBorder;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.KeyEvent;\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Stream;\n\n// GUI interface for UMLie\npublic class UMLieGUI {\n\n    private static final Pattern PACKAGE_NAME_REGEX = Pattern.compile(\"src\\\\/(main\\\\/(java\\\\/)?)?(.*)\\\\/(.*).java\");\n\n    private ImportDiagramParser parser;\n\n    private final UMLangGenerator generator;\n    private final Set<String> takenShortNames;\n    private DiagramType currentDiagramType;\n    private DefaultListModel<String> listModel;\n    private SaveImageButton saveAsImageBtn;\n    private SaveUMLangButton saveUmlButton;\n\n    // EFFECTS: creates a new instance of the UMLie GUI\n    public UMLieGUI() {\n        try {\n            UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n        } catch (Exception e) {\n            System.out.println(\"Couldn't set look and feel, continuing...\");\n        }\n\n        parser = new ImportDiagramParser();\n        generator = new UMLangGenerator(parser);\n        takenShortNames = new HashSet<>();\n        currentDiagramType = DiagramType.PACKAGE;\n\n        JFrame frame = new JFrame();\n\n        JPanel titlePanel = createTitleHeader();\n        JPanel listPanel = createFilesPanel(frame);\n        JPanel saveDiagramPanel = createSaveDiagramPanel();\n        JPanel umlWrapperPanel = createUMLangWrapperPanel();\n\n        frame.setPreferredSize(new Dimension(500, 500));\n        JPanel overallPanel = createWrapperPanel(titlePanel, listPanel, umlWrapperPanel, saveDiagramPanel);\n        frame.add(overallPanel, BorderLayout.CENTER);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setTitle(\"UMLie\");\n        frame.pack();\n        frame.setVisible(true);\n        frame.addWindowListener(new EventLogWindowAdapter());\n    }\n\n    // EFFECTS: creates the files panel with the file list and the file action buttons\n    private JPanel createFilesPanel(JFrame frame) {\n        JPanel listPanel = createFileListPanel();\n        JPanel buttonPanel = createListControlPanel(frame);\n        listPanel.add(buttonPanel);\n        return listPanel;\n    }\n\n    // EFFECTS: creates the wrapper panel around all components, initializes layout\n    private static JPanel createWrapperPanel(JPanel titlePanel, JPanel listPanel, JPanel umlWrapperPanel,\n                                             JPanel saveDiagramPanel) {\n        JPanel mainFunctionalityPanel = new JPanel();\n        GroupLayout layout = new GroupLayout(mainFunctionalityPanel);\n        mainFunctionalityPanel.setLayout(layout);\n        layout.setAutoCreateGaps(true);\n        layout.setAutoCreateContainerGaps(true);\n\n        layout.setHorizontalGroup(\n                layout.createParallelGroup(GroupLayout.Alignment.TRAILING)\n                        .addComponent(saveDiagramPanel)\n                        .addGroup(layout.createSequentialGroup().addComponent(listPanel).addComponent(umlWrapperPanel))\n        );\n        layout.setVerticalGroup(layout.createSequentialGroup()\n                .addComponent(saveDiagramPanel)\n                .addGroup(layout.createParallelGroup().addComponent(listPanel).addComponent(umlWrapperPanel))\n        );\n\n        JPanel overallPanel = new JPanel();\n        overallPanel.setLayout(new BoxLayout(overallPanel, BoxLayout.Y_AXIS));\n        overallPanel.add(titlePanel);\n        overallPanel.add(mainFunctionalityPanel);\n        return overallPanel;\n    }\n\n    // EFFECTS: returns the save diagram panel with the 'save as image' and 'save as UML' buttons\n    private JPanel createSaveDiagramPanel() {\n        JPanel saveDiagramPanel = new JPanel();\n        saveDiagramPanel.setLayout(new BoxLayout(saveDiagramPanel, BoxLayout.X_AXIS));\n        SaveImageButton saveImageButton = new SaveImageButton(generator);\n        this.saveAsImageBtn = saveImageButton;\n        SaveUMLangButton saveUmlButton = new SaveUMLangButton(generator);\n        this.saveUmlButton = saveUmlButton;\n        saveDiagramPanel.add(saveUmlButton);\n        saveDiagramPanel.add(Box.createRigidArea(new Dimension(10, 0)));\n        saveDiagramPanel.add(saveImageButton);\n        return saveDiagramPanel;\n    }\n\n    // EFFECTS: creates the list control panel with the file action buttons\n    private JPanel createListControlPanel(JFrame frame) {\n        JPanel buttonPanel = new JPanel();\n        buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));\n        JButton addNewJavaInput = createAddNewJavaInputButton();\n        buttonPanel.add(addNewJavaInput);\n        buttonPanel.add(Box.createRigidArea(new Dimension(10, 0)));\n        JButton loadFiles = createLoadUMLieFileButton();\n        buttonPanel.add(loadFiles);\n        buttonPanel.add(Box.createRigidArea(new Dimension(10, 0)));\n        JButton saveFiles = createSaveUMLieFileButton();\n        buttonPanel.add(saveFiles);\n        buttonPanel.add(Box.createRigidArea(new Dimension(10, 0)));\n        JButton clearFiles = createClearFilesButton();\n        buttonPanel.add(clearFiles);\n        buttonPanel.setBorder(new EmptyBorder(10, 0, 0, 0));\n        return buttonPanel;\n    }\n\n    // EFFECTS: creates the Java input adder, which opens a file chooser and patches in a package description before\n    // adding them to the parser\n    private JButton createAddNewJavaInputButton() {\n        JButton addNewJavaInput = new JButton(\"Add Java file\");\n        addNewJavaInput.addActionListener(\n                new SaveTypeButtonActionListener(this::getResultAndAddJavaInput, \"Java files\", \"java\", false));\n        return addNewJavaInput;\n    }\n\n    // EFFECTS: gets selected filepath from filechooser and validates Java file\n    // then adds to the parser\n    private void getResultAndAddJavaInput(JFileChooser fileChooser) {\n        File selectedFile = fileChooser.getSelectedFile();\n        String filePath = selectedFile.getAbsolutePath();\n        if (filePath.length() == 0 || takenShortNames.contains(filePath)) {\n            JOptionPane.showMessageDialog(null,\n                    filePath + \" has been added already. Please choose another name.\");\n            return;\n        }\n        if (!filePath.endsWith(\".java\")) {\n            JOptionPane.showMessageDialog(null, \"This doesn't look like a Java file. Please rename your \"\n                    + \"file to end in .java or try another Java file.\");\n            return;\n        }\n        createAndAddJavaInput(filePath);\n    }\n\n    // MODIFIES: this\n    // EFFECTS: patches package information in and adds Java input to the parser\n    private void createAndAddJavaInput(String filePath) {\n        StringBuilder contentBuilder = new StringBuilder();\n        String fileContents;\n        try (Stream<String> stream = Files.lines(Paths.get(filePath), StandardCharsets.UTF_8)) {\n            stream.forEach(s -> contentBuilder.append(s).append(\"\\n\"));\n            fileContents = contentBuilder.toString().trim();\n            if (fileContents.length() != 0) {\n                // if no package declaration, try to create one from the pathname\n                if (!fileContents.trim().startsWith(\"package\")) {\n                    Matcher matcher = PACKAGE_NAME_REGEX.matcher(filePath);\n                    if (matcher.find() && matcher.group(2).length() == 0) {\n                        String packageName = matcher.group(2).replace(\"\\\\/\", \".\");\n                        fileContents = \"package \" + packageName + \";\\n\" + fileContents;\n                    }\n                }\n                addJavaInputToGUI(filePath, fileContents);\n            } else {\n                throw new IOException();\n            }\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null,\n                    \"File was empty or could not be read. Try another file.\");\n        }\n    }\n\n    // MODIFIES: this\n    // EFFECTS: adds the Java Input to the GUI\n    private void addJavaInputToGUI(String filePath, String fileContents) {\n        parser.addJavaInput(new JavaInput(filePath, fileContents));\n        takenShortNames.add(filePath);\n        listModel.addElement(filePath);\n        saveAsImageBtn.setEnabled(true);\n        saveUmlButton.setEnabled(true);\n    }\n\n    // EFFECTS: creates the UML load file button, which opens a file chooser and reads the UMLie save file in\n    private JButton createLoadUMLieFileButton() {\n        JButton loadFiles = new JButton(\"Load UMLie file\");\n        loadFiles.addActionListener(new SaveTypeButtonActionListener((JFileChooser fileChooser) -> {\n            File selectedFile = fileChooser.getSelectedFile();\n            String filePath = selectedFile.getAbsolutePath();\n            JsonReader jsonReader = new JsonReader(filePath);\n            try {\n                setUMLieStateFromJson(jsonReader);\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Error reading the file.\");\n            }\n        }, \"UMLie file\", \"json\", true));\n        return loadFiles;\n    }\n\n    // MODIFIES: this\n    // EFFECTS: sets GUI state from loaded JSON file\n    private void setUMLieStateFromJson(JsonReader jsonReader) throws IOException {\n        parser = jsonReader.read();\n        generator.setParser(parser);\n        for (JavaInput javaInput : parser.getJavaInputs()) {\n            listModel.addElement(javaInput.getShortName());\n        }\n        if (parser.getJavaInputs().size() != 0) {\n            saveAsImageBtn.setEnabled(true);\n            saveUmlButton.setEnabled(true);\n        }\n    }\n\n    // EFFECTS: creates the UML file save button, which opens the file selector and writes UMLie state to JSON\n    private JButton createSaveUMLieFileButton() {\n        JButton saveFiles = new JButton(\"Save UMLie file\");\n        saveFiles.addActionListener(new SaveTypeButtonActionListener((JFileChooser fileChooser) -> {\n            File selectedFile = fileChooser.getSelectedFile();\n            String filePath = selectedFile.getAbsolutePath();\n            JsonWriter writer = new JsonWriter(filePath);\n            try {\n                writer.write(parser);\n            } catch (FileNotFoundException ex) {\n                JOptionPane.showMessageDialog(null, \"Error reading the file.\");\n            }\n        }, \"UMLie files\", \"json\", false));\n        return saveFiles;\n    }\n\n    // EFFECTS: creates the file clear button, which resets program state\n    private JButton createClearFilesButton() {\n        JButton clearFiles = new JButton(\"Clear all files\");\n        clearFiles.addActionListener(e -> {\n            parser.clearJavaInputs();\n            generator.setParser(parser);\n            listModel.clear();\n            saveAsImageBtn.setEnabled(false);\n            saveUmlButton.setEnabled(false);\n        });\n        return clearFiles;\n    }\n\n    // EFFECTS: creates the UML wrapper panel with the UML image display\n    private JPanel createUMLangWrapperPanel() {\n        JPanel umlWrapperPanel = new JPanel();\n        umlWrapperPanel.setLayout(new BoxLayout(umlWrapperPanel, BoxLayout.Y_AXIS));\n        JPanel umlPanel = new JPanel();\n        umlPanel.setBackground(new Color(0x424242));\n        JLabel umlPlaceholder = new JLabel(\"Generate a diagram or add more files to get started.\", JLabel.CENTER);\n        umlPanel.setLayout(new BorderLayout());\n        umlPanel.add(umlPlaceholder, BorderLayout.CENTER);\n        umlWrapperPanel.add(umlPanel);\n\n        JPanel umlControlPanel = createUMLangControlPanel(umlPanel);\n        umlWrapperPanel.add(umlControlPanel);\n        return umlWrapperPanel;\n    }\n\n    // EFFECTS: creates the UML control panel with the diagram type picker buttons\n    private JPanel createUMLangControlPanel(JPanel umlPanel) {\n        JPanel umlControlPanel = new JPanel();\n        umlControlPanel.setLayout(new BoxLayout(umlControlPanel, BoxLayout.X_AXIS));\n        JButton packageButton = new ImageGeneratorButton(DiagramType.PACKAGE, umlPanel,\n                generator, () -> {\n            setCurrentDiagramType(DiagramType.PACKAGE);\n        }, saveAsImageBtn, saveUmlButton);\n        umlControlPanel.add(packageButton);\n        umlControlPanel.add(Box.createRigidArea(new Dimension(10, 0)));\n        JButton importsButton = new ImageGeneratorButton(DiagramType.CLASS_IMPORT, umlPanel,\n                generator, () -> {\n            setCurrentDiagramType(DiagramType.CLASS_IMPORT);\n        }, saveAsImageBtn, saveUmlButton);\n        umlControlPanel.add(importsButton);\n        umlControlPanel.add(Box.createRigidArea(new Dimension(10, 0)));\n        JButton relationshipsButton = new ImageGeneratorButton(DiagramType.CLASS_RELATIONSHIP, umlPanel,\n                generator, () -> {\n            setCurrentDiagramType(DiagramType.CLASS_RELATIONSHIP);\n        }, saveAsImageBtn, saveUmlButton);\n        umlControlPanel.add(relationshipsButton);\n        umlControlPanel.setBorder(new EmptyBorder(10, 0, 0, 0));\n        return umlControlPanel;\n    }\n\n\n    // EFFECTS: returns the title header panel\n    private JPanel createTitleHeader() {\n        JLabel title = new JLabel(\"Welcome to UMLie!\", JLabel.CENTER);\n        Font newLabelFont = new Font(title.getFont().getName(), Font.BOLD, title.getFont().getSize());\n        title.setFont(newLabelFont);\n        title.setAlignmentX(JLabel.CENTER_ALIGNMENT);\n        JPanel titlePanel = new JPanel();\n        titlePanel.setBorder(new EmptyBorder(20, 20, 0, 20));\n        titlePanel.add(title);\n        return titlePanel;\n    }\n\n    // MODIFIES: this\n    // EFFECTS: returns the file list panel\n    private JPanel createFileListPanel() {\n        JPanel listPanel = new JPanel();\n        listPanel.setLayout(new BoxLayout(listPanel, BoxLayout.Y_AXIS));\n        DefaultListModel listModel = new DefaultListModel();\n        this.listModel = listModel;\n\n        JList list = new JList(listModel);\n        list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        list.setSelectedIndex(0);\n        list.setVisibleRowCount(5);\n        addDeleteKeybinding(listModel, list);\n\n        JScrollPane listScrollPane = new JScrollPane(list);\n        listPanel.add(listScrollPane);\n        return listPanel;\n    }\n\n    // MODIFIES: listModel, list\n    // EFFECTS: binds the delete key to delete the currently selected listModel element\n    private void addDeleteKeybinding(DefaultListModel listModel, JList list) {\n        InputMap inputMap = list.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);\n        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0), \"deleteListSelection\");\n        ActionMap actionMap = list.getActionMap();\n        // taken from https://stackoverflow.com/a/65487077\n        actionMap.put(\"deleteListSelection\", new AbstractAction() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                String selected =\n                        listModel.getElementAt(list.getSelectedIndex()).toString();\n                for (JavaInput javaInput : parser.getJavaInputs()) {\n                    if (javaInput.getShortName().equals(selected)) {\n                        parser.removeJavaInput(javaInput);\n                        break;\n                    }\n                }\n                if (parser.getJavaInputs().size() == 0) {\n                    saveAsImageBtn.setEnabled(false);\n                    saveUmlButton.setEnabled(false);\n                }\n                listModel.removeElementAt(list.getSelectedIndex());\n                list.repaint();\n            }\n        });\n    }\n\n    // setters\n\n    public void setCurrentDiagramType(DiagramType currentDiagramType) {\n        this.currentDiagramType = currentDiagramType;\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/ui/UMLieGUI.java"
    },
    {
        "contents": "package ui.components;\n\nimport model.Event;\nimport model.EventLog;\n\nimport java.awt.event.WindowAdapter;\n\n// a window adapter to log events to the console before quitting\npublic class EventLogWindowAdapter extends WindowAdapter {\n    // EFFECTS: prints all events in the event log to the console\n    @Override\n    public void windowClosing(java.awt.event.WindowEvent e) {\n        System.out.println(\"UMLie Event Log:\");\n        for (Event ev : EventLog.getInstance()) {\n            System.out.println(ev.toString());\n        }\n        System.exit(0);\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/ui/components/EventLogWindowAdapter.java"
    },
    {
        "contents": "package ui.components;\n\nimport model.DiagramType;\nimport model.UMLangGenerator;\nimport net.sourceforge.plantuml.SourceStringReader;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.*;\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n// generates images from parser state\npublic class ImageGenerator {\n    private final UMLangGenerator generator;\n\n    public ImageGenerator(UMLangGenerator generator) {\n        this.generator = generator;\n    }\n\n    // MODIFIES: this\n    // EFFECTS: generates image from current generator UML\n    public BufferedImage generateImage(DiagramType type) {\n        // taken from https://plantuml.com/api\n        String source = generator.generateDiagramForType(type);\n        if (source.replace(\"@startuml\", \"\").replace(\"@enduml\", \"\")\n                .replace(\"\\n\", \"\").trim().length() == 0) {\n            return null;\n        }\n        ByteArrayOutputStream currentDiagram = new ByteArrayOutputStream();\n        SourceStringReader reader = new SourceStringReader(source);\n        try {\n            reader.outputImage(currentDiagram);\n        } catch (IOException ex) {\n            throw new RuntimeException(ex);\n        }\n        InputStream inputStream = new ByteArrayInputStream(currentDiagram.toByteArray());\n        try {\n            return ImageIO.read(inputStream);\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \"Couldn't render UML, try again.\");\n        }\n        return null;\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/ui/components/ImageGenerator.java"
    },
    {
        "contents": "package ui.components;\n\nimport model.DiagramType;\nimport model.UMLangGenerator;\n\nimport javax.swing.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.image.BufferedImage;\n\n// action listener to generate images from UML on button click\npublic class ImageGeneratorActionListener extends ImageGenerator implements ActionListener {\n    private final JPanel umlPanel;\n    private final Runnable function;\n    private final DiagramType type;\n    private final JButton imgBtn;\n    private final JButton umlBtn;\n\n    // EFFECTS: creates a new image generator listeners with associated JPanel, diagram type, and diagram generator\n    public ImageGeneratorActionListener(JPanel umlPanel, DiagramType type, UMLangGenerator generator,\n                                        Runnable function, JButton imgBtn, JButton umlBtn) {\n        super(generator);\n        this.umlPanel = umlPanel;\n        this.type = type;\n        this.function = function;\n        this.imgBtn = imgBtn;\n        this.umlBtn = umlBtn;\n    }\n\n    // MODIFIES: this\n    // EFFECTS: sets the UML panel's contents to the displayed diagram or a placeholder message if no files are present\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        function.run();\n        umlPanel.remove(0);\n        BufferedImage image = generateImage(type);\n        if (image == null) {\n            JLabel umlPlaceholder = new JLabel(\"Add more files to get started.\", JLabel.CENTER);\n            umlPanel.add(umlPlaceholder);\n            imgBtn.setEnabled(false);\n            umlBtn.setEnabled(false);\n        } else {\n            JLabel imageAsLabel = new JLabel(new ImageIcon(image));\n            umlPanel.add(imageAsLabel);\n        }\n        umlPanel.revalidate();\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/ui/components/ImageGeneratorActionListener.java"
    },
    {
        "contents": "package ui.components;\n\nimport model.DiagramType;\nimport model.UMLangGenerator;\n\nimport javax.swing.*;\n\n// creates an image generator button based on the diagram type\npublic class ImageGeneratorButton extends JButton {\n    // MODIFIES: this, imageBtn, umlBtn\n    // EFFECTS: instantiates a new JButton to generate the appropriate image type\n    public ImageGeneratorButton(DiagramType diagramType, JPanel umlPanel, UMLangGenerator generator,\n                                Runnable function, SaveTypeButton imageBtn, SaveTypeButton umlBtn) {\n        super(diagramType == DiagramType.CLASS_IMPORT ? \"Class imports\" :\n                (diagramType == DiagramType.CLASS_RELATIONSHIP ? \"Class relationships\" : \"Package relationships\"));\n        addActionListener(\n                new ImageGeneratorActionListener(umlPanel, diagramType, generator, function, imageBtn, umlBtn));\n        imageBtn.setCurrentDiagramType(diagramType);\n        umlBtn.setCurrentDiagramType(diagramType);\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/ui/components/ImageGeneratorButton.java"
    },
    {
        "contents": "package ui.components;\n\nimport model.DiagramType;\nimport model.UMLangGenerator;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\n// button to save the diagram as an image\npublic class SaveImageButton extends SaveTypeButton {\n    // EFFECTS: creates a new JButton with 'Save as Image' text\n    public SaveImageButton(UMLangGenerator generator) {\n        super(generator, \"Save as Image\");\n        addActionListener(new SaveTypeButtonActionListener((JFileChooser fileChooser) -> {\n            saveImage(fileChooser);\n        }, \"PNG images\", \"png\", false));\n    }\n\n    // EFFECTS: saves the image to the file\n    private void saveImage(JFileChooser fileChooser) {\n        ImageGenerator imageGen = new ImageGenerator(generator);\n        try {\n            BufferedImage image = imageGen.generateImage(currentDiagramType);\n            File selectedFile = fileChooser.getSelectedFile();\n            ImageIO.write(image, \"png\", selectedFile);\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \"Couldn't write to file, try again.\");\n        }\n    }\n\n    // setters\n    public void setCurrentDiagramType(DiagramType currentDiagramType) {\n        this.currentDiagramType = currentDiagramType;\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/ui/components/SaveImageButton.java"
    },
    {
        "contents": "package ui.components;\n\nimport model.DiagramType;\nimport model.UMLangGenerator;\n\nimport javax.swing.*;\n\n// button to save the diagram as an image\npublic class SaveTypeButton extends JButton {\n    protected UMLangGenerator generator;\n    protected DiagramType currentDiagramType;\n\n    // EFFECTS: creates a new JButton with the correct text\n    public SaveTypeButton(UMLangGenerator generator, String text) {\n        super(text);\n        setEnabled(false);\n        this.generator = generator;\n    }\n\n    // setters\n    public void setCurrentDiagramType(DiagramType currentDiagramType) {\n        this.currentDiagramType = currentDiagramType;\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/ui/components/SaveTypeButton.java"
    },
    {
        "contents": "package ui.components;\n\nimport javax.swing.*;\nimport javax.swing.filechooser.FileNameExtensionFilter;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.util.function.Consumer;\n\n// action listener class to run the appropriate function for 'save as type' buttons\npublic class SaveTypeButtonActionListener implements ActionListener {\n    private Consumer<JFileChooser> function;\n    private String description;\n    private String extensions;\n    private boolean loadInstead;\n\n    // EFFECTS: creates a new ActionListener that associates the subfunction to run with the action listener\n    public SaveTypeButtonActionListener(Consumer<JFileChooser> function, String description, String extensions,\n                                        boolean loadInstead) {\n        this.function = function;\n        this.description = description;\n        this.extensions = extensions;\n        this.loadInstead = loadInstead;\n    }\n\n    // EFFECTS: displays a file chooser window and runs the consumer function on the selected file\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        FileNameExtensionFilter filter = new FileNameExtensionFilter(description, extensions);\n        JFileChooser fileChooser = new JFileChooser(\"/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d\"\n                + \"/src/main\");\n        fileChooser.setFileFilter(filter);\n        int result = loadInstead ? fileChooser.showOpenDialog(null) : fileChooser.showSaveDialog(null);\n        if (result == JFileChooser.APPROVE_OPTION) {\n            function.accept(fileChooser);\n        }\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/ui/components/SaveTypeButtonActionListener.java"
    },
    {
        "contents": "package ui.components;\n\nimport model.UMLangGenerator;\nimport persistence.UMLangWriter;\n\nimport javax.swing.*;\nimport java.io.File;\nimport java.io.IOException;\n\n// button to save the diagram as a UML file\npublic class SaveUMLangButton extends SaveTypeButton {\n    // EFFECTS: creates a new JButton with 'Save as UML' text\n    public SaveUMLangButton(UMLangGenerator generator) {\n        super(generator, \"Save as UML\");\n        addActionListener(new SaveTypeButtonActionListener((JFileChooser fileChooser) -> {\n            saveUML(fileChooser);\n        }, \"UML files\", \"uml\", false));\n    }\n\n    // EFFECTS: saves the UML to the file\n    private void saveUML(JFileChooser fileChooser) {\n        File selectedFile = fileChooser.getSelectedFile();\n        String filePath = selectedFile.getAbsolutePath();\n        UMLangWriter writer = new UMLangWriter(filePath, generator);\n        try {\n            writer.writeUML(currentDiagramType);\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \"Couldn't write to file, try again.\");\n        }\n    }\n}",
        "shortName": "/home/kewbish/Downloads/education/cpsc210/projs/project_h4i7d/src/main/ui/components/SaveUMLangButton.java"
    }
]}